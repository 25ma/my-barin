#知识大纲 #数据库 

# Mysql大纲

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220505002334.png)

- 数据库中的建
	1. 超键：唯一标记元祖的属性集
	2. 候选键：超键中不包含多余的属性
	3. 主键：候选键选择一个作为主键
	4. 外键
	5. 主属性
	6. 非主属性
- 数据库范式
	1. 1NF：列不可拆分
	2. 2NF：非主属性完全依赖候选键，不能部分依赖，否则造成数据冗余与耦合。消除非主属性对键的部分函数依赖。
	3. 3NF：非主属性不能与候选键存在传递依赖。消除非主属性对键的传递函数依赖。
	4. BCNF：任意字段不能与候选键存在传递依赖。消除主属性对键对传递函数依赖。
- Mysql 常用引擎
	- MyISAM，全表锁，无事务、外键，非聚集索引。
	- Innodb，行级锁，有提交回滚等事务特性。支持自增列，外键，并发强。占用空间是 MyISAM 的 2.5 倍。主键为聚集索引。
	- Memory，表锁
	- Merge，MyISAM 表的组合
- 数据库事务 ACID
- Mysql 索引
	- 聚集索引，Mysql 会自动将主键索引放到其他索引的后面
	- 覆盖索引：在联合索引上就有待查询待全部字段无需回表。
		- 索引下推：当索引上条件能判断时就不会回表判断。
	- 联合索引
		- 联合索引的最左匹配原则，从左边开始的字段能走上索引，遇到范围查询 (>,<, between, like 停止)
		- 若 (a, b) 为联合索引，查询条件 b = xx and a = xx 也能走上索引，引擎会自动优化。
	- 前缀索引，Mysql 支持指定字符串或二进制的前 n 位构建索引。
	- 唯一索引
	- 索引重建
		- 目的：索引可能因为删除，页分裂等原因造成数据空洞。重建索引会创建新的索引，时页面利用率最高。索引更紧凑，更省空间。
		- 重建非主键索引：`drop index`
		- 重建主键索引：避免使用 `drop primary key`，因为这个会先删除旧的主键索引，然后 innodb 又自己使用了一个临时主键索引，最后又自己指定了主键索引。导致主键重构两次。用 `alter table T engine=InnoDB` 代替。
	- 自适应哈希索引
- SQL 优化的途径
	- 不要使用 select *
	- 减少子查询，用关联查询代替。子查询会生成临时表，关联查询不会。
	- 当子查询表大时，用 exists。子查询表小时，用 in。另无论哪个表大，not in 会扫全表，not exists 可以使用到索引。
	- Or 的查询看情况是否可以使用 union 或 union all 代替。
	- 减少 != 条件的使用，否则会全表扫描。
	- 避免在 where 条件中进行 null 值判断，否则可能会全表扫描。
	- 避免在 where 条件中对字段进行函数计算
- Truncate、drop、delete 区别
	- Truncate 和 drop 不走事务，不触发trigger。
	- Truncate 和 drop 是 ddl 语句。Delete 是 dml 语句。
- 并发带来的问题
	- 脏读
	- 丢失修改
	- 不可重复读
	- 幻读
- 数据库隔离级别
	- Read-UnCommitter
	- Read-Committed
	- Repeatable-Read
		在此隔离级别下，存在 MVCC 模式。对于每一个操作，都会产生一个 undo 日志，undo 日志会和事务产生关联。因此如果一个事务非常长的话那么就会占用很大的 undo 日志空间。Undo 日志删除的条件是没有比这个日志更早的 read-view，所以要尽量避免长事务。
	- Serializable
- 大表优化的思路
	- 限定查询范围
	- 读写分离
	- 垂直分区，拆列
	- 水平分区，拆行
	- 分库分表
-  数据库分片两种常见方案
	- 客户端代理，如 Sharding-Jdbc。封装在 jar 包中，通过修改或封装 jdbc 实现。
	- Mycat，中间件代理。处于应用和数据层之间。
- 分库分表后 id 解决方案
	- UUID
	- 数据库自增 ID。设置不同步长与 ID 生成策略。
	- 利用 Redis 中间件生成。
	- SnowFlake 算法。
	- 其他分布式 ID 生成系统，如美团的 Leaf。
- SQL 的执行流程
	1. 取得数据库连接器
	2. 查询缓存，Mysql8.0 中已移除
	3. SQL 词法分析
	4. 优化器优化，如使用哪个索引，join 连接顺序
	5. 执行器执行
- SQL 语句的执行顺序
	1. From 表做笛卡尔积
	2. 执行 On 过滤
	3. 添加外部行，这里在左连接或右连接才会有
	4. 执行 Where 过滤
	5. 执行 Group By 分组
	6. 执行 Having 过滤
	7. 执行 Select 列选择
	8. 执行 Distinct 过滤数据 (这里会生成临时表，在过滤列上加唯一索引)
	9. 执行 Order By 语句
	10. 执行 Limit 语句
- Varchar (11) 与 int (11) 区别，Varchar 指定存储长度，int 指定显示长度。注意 Varchar 的 OrderBy 排序时使用 fixed_length 计算 col 长度。
- MVCC 的实现原理
	- Undo 日志：记录数据的历史变化情况，通过 undo 日志可以追溯到以前的数据。
	- ReadView
		- Mysql 的数据隐藏列中包含以下几个字段：roll_pointer，指向 undo 日志。Trx_id，指向这条日志产生的源事务 ID。Row_id，当没有主键是隐藏的主键 ID。
		- 在执行增/删/改的时候，每操作一次就会产生一条 undo 日志。Undo 日志包含上述的字段内容，根据 roll_pointer 就可以产生一条版本链。
		- 基于版本链的情况下，当查询操作产生的时候就会构造 ReadView 视图，从版本链中获取数据。生成 ReadView 视图时会包含以下内容：
			- M_ids：生成 ReadView 视图时活跃的事务 ID 列表。
			- Creator_trx_id：生成 ReadView 视图的事务 ID，即当前事务 ID。
			- Max_trx_id：生成 ReadView 视图时应该分配给下一个事务的 ID。
			- Min_trx_id：生成 ReadView 视图时活跃事务列表中最小的事务 ID。
		- MVCC 的规则如下：
			- 若当前版本链上数据的事务 ID 等于 Creator_trx_id，表示数据由当前事务产生，可读。
			- 若当前版本链上数据的事务 ID 大于 Max_trx_id，表示数据是视图创建之后产生的，不可读。往版本链往前找。
			- 若当前版本链上数据的事务 ID 小于 Min_trx_id，表示数据是视图创建之前产生的，可读。
			- 若当前版本链上数据的事务 ID 在 M_ids 列表中
				- 事务未提交：不可读。
				- 事务已提交
					- RC 级别下，数据可读。
					- RR 级别下，需要保持可重复读的特性，因此不可读。有一种特殊情况，若当前事务先对其进行更新操作，更新会触发当前读获取到最新数据更新。更新完之后该数据事务 ID 会变成当前事务 ID，当前事务就可读到了。
- Mysql 的锁
	- 锁分类
		- 按范围分类
			- 数据库锁：对数据库加锁。
				- `Flush tables with read lock (FTWRL)`，使数据库处于只读状态
				- 如果只是备份的话可以使用 `mysqldump–single-transaction` 来保证隔离型的读。注意使用这个语句需要所有数据表都是 InnoDB 引擎的。
				- 使用 `set global readonly=true` 的方式。这种方式有两个问题，其一是这个值通常用来处理一些其他情况，如是主库还是从库。另一个是修改 global 影响大，FTWRL 中断后自动释放锁，而 readonly 设置确不会。
			- 表锁
				- `lock tables ... read/write`，主动开启与释放锁。线程 A 中执行 `lock tables t1 read, t2 write;` 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。
				- MDL (metadata lock)，是 Mysql5.5 版本增加的。会在操作一个表的时候自动加读/写锁。需要注意的是，在修改表结构的时候，**若前面有事务没释放锁，则修改表结构操作会阻塞。表结构操作阻塞后后续所有的请求都会阻塞。**
				- OnlieDDL执行过程
					1. 拿 MDL 写锁
					2. 降级成 MDL 读锁
					3. 真正做 DDL，这里不会阻塞读写操作
					4. 升级成 MDL 写锁
					5. 释放MDL锁
			- 行锁
			- 共享锁
			- 排他锁
		- 按锁机制分类
			- 悲观锁
			- 乐观锁
		- 按锁实现分类
			- S 锁
			- X 锁
			- IS 锁
			- IX 锁
			- Gap 锁
			- Next-key 锁
	- 锁升级
		- 当行锁无法匹配数据时，会升级到表锁
		- 当索引记录超过整表 1/2 时，会走到全表查询。行锁变表锁。
	- 死锁
	- 死锁避免
		- 设定超时时间
		- 设定资源访问顺序
		- 避免事务交叉
		- 使用低隔离级别
		- 主动死锁检测，在尝试获取锁的时候进行死锁检测。当发现自己的操作可能发生阻塞时，就主动回滚事务让其他事务执行。`innodb_deadlock_detect` 默认就是开启的。这里检测的时候不会扫描所有事务，只会扫描和当前线程操作资源相关的事务。
	- 死锁解除
		- 当线程持有锁时间超过 `innodb_lock_wait_timeout` 时，就主动放弃锁回滚事务。这个值默认是 50s。
	- 两段锁协议
		- 在 InnoDB 事务中，行锁是需要的时候加上去的，但并不是不需要了就立刻释放，而是等到事务结束才释放。这就是两阶段锁协议。
		- 如果你的事务需要锁多个行，那么尽可能把造成锁冲突的，影响并发的语句往后放。
- 一条 SQL 执行慢的原因
	- 偶尔慢
		- 数据库在刷新脏页
			- Redo 日志满了
			- 内存满了
			- MySql 正常刷新脏页
			- 正在关机
		- 获取不到锁
	- 一直慢
		- 没正确使用索引
		- 索引没建
		- 由于数据库原因导致索引失效。如是否使用临时表，是否排序，估算的索引扫描行数等。