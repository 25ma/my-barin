#知识大纲 #数据库 

# Mysql大纲

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220505002334.png)

- 数据库中的建
	1. 超键：唯一标记元祖的属性集
	2. 候选键：超键中不包含多余的属性
	3. 主键：候选键选择一个作为主键
	4. 外键
	5. 主属性
	6. 非主属性
- 数据库范式
	1. 1NF：列不可拆分
	2. 2NF：非主属性完全依赖候选键，不能部分依赖，否则造成数据冗余与耦合。消除非主属性对键的部分函数依赖。
	3. 3NF：非主属性不能与候选键存在传递依赖。消除非主属性对键的传递函数依赖。
	4. BCNF：任意字段不能与候选键存在传递依赖。消除主属性对键对传递函数依赖。
- Mysql 常用引擎
	- MyISAM，全表锁，无事务、外键，非聚集索引。
	- Innodb，行级锁，有提交回滚等事务特性。支持自增列，外键，并发强。占用空间是 MyISAM 的 2.5 倍。主键为聚集索引。
	- Memory，表锁
	- Merge，MyISAM 表的组合
- 数据库事务 ACID
- Mysql 索引
	- 聚集索引
	- 覆盖索引：在联合索引上就有待查询待全部字段无需回表。
	- 联合索引
		- 联合索引的最左匹配原则，从左边开始的字段能走上索引，遇到范围查询 (>,<, between, like 停止)
		- 若 (a, b) 为联合索引，查询条件 b = xx and a = xx 也能走上索引，引擎会自动优化。
	- 前缀索引，Mysql 支持指定字符串或二进制的前 n 位构建索引。
	- 唯一索引
- SQL 优化的途径
	- 不要使用 select *
	- 减少子查询，用关联查询代替。子查询会生成临时表，关联查询不会。
	- 当子查询表大时，用 exists。子查询表小时，用 in。另无论哪个表大，not in 会扫全表，not exists 可以使用到索引。
	- Or 的查询看情况是否可以使用 union 或 union all 代替。
	- 减少 != 条件的使用，否则会全表扫描。
	- 避免在 where 条件中进行 null 值判断，否则可能会全表扫描。
	- 避免在 where 条件中对字段进行函数计算
- Truncate、drop、delete 区别
	- Truncate 和 drop 不走事务，不触发trigger。
	- Truncate 和 drop 是 ddl 语句。Delete 是 dml 语句。
- 并发带来的问题
	- 脏读
	- 丢失修改
	- 不可重复读
	- 幻读
- 数据库隔离级别
	- Read-UnCommitter
	- Read-Committed
	- Repeatable-Read
	- Serializable
- 大表优化的思路
	- 限定查询范围
	- 读写分离
	- 垂直分区，拆列
	- 水平分区，拆行
	- 分库分表
-  数据库分片两种常见方案
	- 客户端代理，如 Sharding-Jdbc。封装在 jar 包中，通过修改或封装 jdbc 实现。
	- Mycat，中间件代理。处于应用和数据层之间。
- 分库分表后 id 解决方案
	- UUID
	- 数据库自增 ID。设置不同步长与 ID 生成策略。
	- 利用 Redis 中间件生成。
	- SnowFlake 算法。
	- 其他分布式 ID 生成系统，如美团的 Leaf。
- SQL 的执行流程
	1. 取得数据库连接器
	2. 查询缓存，Mysql8.0 中已移除
	3. SQL 词法分析
	4. 优化器优化，如使用哪个索引，join 连接顺序
	5. 执行器执行
- SQL 语句的执行顺序
	1. From 表做笛卡尔积
	2. 执行 On 过滤
	3. 添加外部行，这里在左连接或右连接才会有
	4. 执行 Where 过滤
	5. 执行 Group By 分组
	6. 执行 Having 过滤
	7. 执行 Select 列选择
	8. 执行 Distinct 过滤数据 (这里会生成临时表，在过滤列上加唯一索引)
	9. 执行 Order By 语句
	10. 执行 Limit 语句
- Varchar (11) 与 int (11) 区别，Varchar 指定存储长度，int 指定显示长度。注意 Varchar 的 OrderBy 排序时使用 fixed_length 计算 col 长度。
- MVCC 的实现原理
	- Undo 日志
	- Redo 日志
	- ReadView
- Mysql 的锁
	- 锁分类
		- 按范围分类
			- 行锁
			- 表锁
			- 共享锁
			- 排他锁
		- 按锁机制分类
			- 悲观锁
			- 乐观锁
		- 按锁实现分类
			- S 锁
			- X 锁
			- IS 锁
			- IX 锁
			- Gap 锁
			- Next-key 锁
	- 锁升级
		- 当行锁无法匹配数据时，会升级到表锁
		- 当索引记录超过整表 1/2 时，会走到全表查询。行锁变表锁。
	- 死锁避免
		- 设定超时时间
		- 设定资源访问顺序
		- 避免事务交叉
		- 使用低隔离级别
- 一条 SQL 执行慢的原因
	- 偶尔慢
		- 数据库在刷新脏页
			- Redo 日志满了
			- 内存满了
			- MySql 正常刷新脏页
			- 正在关机
		- 获取不到锁
	- 一直慢
		- 没正确使用索引
		- 索引没建
		- 由于数据库原因导致索引失效。如是否使用临时表，是否排序，估算的索引扫描行数等。