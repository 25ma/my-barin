#设计模式

# 一、创建型模式

## 1. 简单工厂模式

现实生活中，原始社会自给自足（没有工厂），农耕社会小作坊（简单工厂，民间酒坊），工业革命流水线（工厂方法，自产自销），现代产业链代工厂（抽象工厂，富士康）。我们的项目代码同样是由简到繁一步一步迭代而来的，但对于调用者来说，却越来越简单。

在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。

注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。

### 工厂模式的定义

定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的 “创建与使用相分离” 的特点。

按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。

我们把被创建的对象称为 “产品”，把创建产品的对象称为 “工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫 “简单工厂模式”。

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。

简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。

简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了 “开闭原则”。

 “工厂方法模式” 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

### 优点和缺点

#### 优点

1.  工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
2.  客户端无需知道所创建具体产品的类名，只需知道参数即可。
3.  也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

#### 缺点

1.  简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
2.  使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
3.  系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
4.  简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 应用场景

对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。

### 模式的结构与实现

简单工厂模式的主要角色如下：

*   简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
*   抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
*   具体产品（ConcreteProduct）：是简单工厂模式的创建目标。

其结构图如下图所示。
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220406220957.png)  


## 2. 工厂方法模式

在[[设计模式#1 简单工厂模式|简单工厂模式]]一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而 “工厂方法模式” 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。  

### 优点和缺点

#### 优点

*   用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
*   灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
*   典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

#### 缺点

*   类的个数容易过多，增加复杂度
*   增加了系统的抽象性和理解难度
*   抽象产品只能生产一种产品，此弊端可使用[[设计模式#3 抽象工厂模式|抽象工厂模式]]解决。

### 应用场景：

*   客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
*   创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
*   客户不关心创建产品的细节，只关心产品的品牌

### 模式的结构与实现

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成。本节来分析其基本结构和实现方法。  

1.  抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct () 来创建产品。
2.  具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220406221236.png)

注意：当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。

## 3. 抽象工厂模式

前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。同种类称为同等级，也就是说：

前面介绍的[[设计模式#2 工厂方法模式|工厂方法模式]]中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。

同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。

本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220406221044.png)

### 模式的定义与特点

抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

使用抽象工厂模式一般要满足以下条件。

*   系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
*   系统一次只可能消费其中某一族产品，即同族的产品一起使用。

#### 优点
抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。

*   可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
*   当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
*   抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

#### 缺点

其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

### 模式的结构与实现

抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。

抽象工厂模式的主要角色如下。

1.  抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct ()，可以创建多个不同等级的产品。
2.  具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

抽象工厂模式的结构图如图 2 所示。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220406221104.png)  



### 模式的应用场景

抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 JAVA 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。

抽象工厂模式通常适用于以下场景：

1.  当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
2.  系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
3.  系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

### 模式的扩展

抽象工厂模式的扩展有一定的 “开闭原则” 倾斜性：

1.  当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
2.  当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。

### 进阶阅读

*   [《抽象工厂在 Java 源码中的应用》](http://c.biancheng.net/view/vip_8392.html)
*   [《抽象工厂模式在 Spring 源码中的应用》](http://c.biancheng.net/view/vip_8393.html)

# 二、结构型模式

## 1. 代理模式

在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

### 代理模式的定义与特点

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

#### 优点有

*   代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
*   代理对象可以扩展目标对象的功能；
*   代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

#### 缺点

*   代理模式会造成系统设计中类的数量增加
*   在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
*   增加了系统的复杂度；

**那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式。**

### 代理模式的结构

代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。

代理模式的主要角色如下。

1.  抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2.  真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
3.  代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

其结构图如图所示：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220407130819.gif)  

在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。

根据代理的创建时期，代理模式分为静态代理和动态代理。

*   静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 . class 文件就已经存在了。
*   动态：在程序运行时，运用反射机制动态创建而成

### 代理模式的应用场景

当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

前面分析了代理模式的结构与特点，现在来分析以下的应用场景。

*   远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
*   虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
*   安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
*   智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
*   延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，[Hibernate](http://c.biancheng.net/hibernate/) 中就存在属性的延迟加载和关联表的延时加载。

### 代理模式的扩展

在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。

1.  真实主题与代理主题一一对应，增加真实主题也要增加代理。
2.  设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 [Spring](http://c.biancheng.net/spring/) AOP，其结构图如图 4 所示。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220407130814.gif)  


### 与其他模式的关系

-   [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。

-   [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同。

-   [[设计模式#2 装饰器模式|装饰器模式]]和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。**两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。**

### 进阶阅读

如果您想深入了解代理模式，可猛击阅读以下文章。

*   [《静态代理和动态代理》](http://c.biancheng.net/view/8424.html)
*   [《使用代理模式切换数据源》](http://c.biancheng.net/view/vip_8427.html)
*   [《彻底搞懂 JDK 动态代理核心原理》](http://c.biancheng.net/view/vip_8429.html)
*   [《代理模式在 Spring 源码中的应用》](http://c.biancheng.net/view/vip_8433.html)
*   [《代理模式在 MyBatis 源码中的应用》](http://c.biancheng.net/view/vip_8435.html)

## 2. 装饰器模式

上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么 “加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。  
在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。  

### 装饰器模式的定义与特点

装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。  

#### 优点

装饰器模式的主要优点有：

*   装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用

*   通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果

*   装饰器模式完全遵守开闭原则

#### 缺点

其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。  

### 装饰器模式的结构与实现

通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。

装饰器模式主要包含以下角色：

1.  抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2.  具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3.  抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4.  具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

装饰器模式的结构图如图所示：
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220407130808.gif)  

### 装饰器模式的应用场景

前面讲解了关于装饰器模式的结构与特点，下面介绍其适用的应用场景，装饰器模式通常在以下几种情况使用。

*   当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是最终类或者采用继承方式会产生大量的子类。

*   当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。

*   当对象的功能要求可以动态地添加，也可以再动态地撤销时。

装饰器模式在 [Java](/java/) 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。  
下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：

```java
BufferedReader in = new BufferedReader(new FileReader("filename.txt"));
String s = in.readLine();

```


### 装饰器模式的扩展

装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。  
- 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图所示:
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220407130803.gif)  

- 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图所示：
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220407130757.gif)  

### 与其他模式的关系

-   [适配器模式](https://refactoringguru.cn/design-patterns/adapter)可以对已有对象的接口进行修改，装饰模式则能在不改变对象接口的前提下强化对象功能。此外，装饰器还支持递归组合，适配器则无法实现。

-   [适配器](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [[设计模式#1 代理模式|代理模式]]能为对象提供相同的接口，装饰则能为对象提供加强的接口。

-   [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。
    [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。

-   [组合模式](https://refactoringguru.cn/design-patterns/composite)和装饰的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。
    装饰类似于组合，但其只有一个子组件。此外还有一个明显不同： 装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了 “求和”。
    但是，模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。

-   大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和装饰的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。

-   装饰可让你更改对象的外表， [策略模式](https://refactoringguru.cn/design-patterns/strategy)则让你能够改变其本质。

-   装饰和 [[设计模式#1 代理模式|代理模式]]有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。 **两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。**

### 进阶阅读

如果您想深入了解装饰器模式，可猛击阅读以下文章。

*   [《使用装饰器模式解决煎饼 “加码” 问题》](/view/vip_8461.html)
*   [《装饰器模式在 JDK 源码中的应用》](/view/vip_8463.html)
*   [《装饰器模式在 Spring 源码中的应用》](/view/vip_8464.html)
*   [《装饰器模式和代理模式的区别》](/view/vip_8466.html)
