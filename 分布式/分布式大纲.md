#知识大纲 #分布式 

# 分布式大纲

- 分布式幂等性如何设计？
	- 针对数据字段做唯一索引
	- 使用 token 机制，提交时获取 token，操作完成删除 token。使用 token 要注意并发问题，防止 token 的 select 与 delete 出现并发问题。
	- 使用悲观锁，可用数据库锁或分布式锁实现。
	- 使用乐观锁，如版本号机制。
	- 状态机幂等，仅合法状态变更才可继续。
- 一次 HTTP 请求经历的步骤
	1. 通过 DNS 协议将域名解析成 IP，如果该域名有 CDN 的话，则返回 CDN 地址。
		- 无 CDN 的情况
			1. 首先从浏览器缓存中加载。
			2. 浏览器缓存没有查看本地 host 文件。
			3. 本地 host 文件没有查找根域名服务器。
			4. 根域名服务器没有再转发到顶级域名服务器，递归查询直到找到对应的 IP 地址。
		- 有 CDN 的情况
			1. CDN 第一步也会进行 DNS 解析，不过解析返回的不是 IP 地址而是 cname 加速域名。
			2. CDN 根据负载情况返回一个实际请求的 IP 地址。
	2. 判断浏览器是否存在缓存，若存在缓存直接使用缓存数据，否则进行请求查询
		- 强缓存：根据 expires 和 cache-control 控制判断。
		- 协商缓存：如 last-modified 头到服务器进行缓存对比。
	3. 开始进行 HTTP 请求，进行三次握手与四次挥手协议
	4. TCP 连接建立完毕，发送请求获得数据
		1. TCP 到底网络层，进行 IP 包组装。通过 OSPF 协议进行路由转发，ARP 协议进行 IP 地址与 MAC 地址的映射。
		2. IP 层数据到达数据链路层，将数据转化为 01 信号交给物理层传输。
	5. 浏览器得到数据，进行渲染响应
- 分布式事务
	- CAP 定理：在一个分布式系统中，最多实现以下两点，不能三点兼顾
		- Consistency 一致性。
		- Availability 可用性。
		- Partition-Tolerance 分区容错性。
	- BASE 理论
- 负载均衡算法
	- 轮询
	- 加权轮询
	- 随机
	- 最少连接
	- 原地址 hash
- 限流算法
	- 计数器算法：设定一个阈值，每次访问时计数器+1，达到阈值限流，每周期清空。存在临界访问压力大的问题，周期结束与下一个周期开始期间可能出现两倍的请求量。这违背了限流的原则。
	- 滑动窗口算法：将时间周期分为更小的周期，总周期内访问阈值固定。滑动窗口清除过期的小周期。窗口拆分的越小，滑动越平稳，限流统计越准确。
	- 漏桶算法
		- 请求到达时放入漏桶，超过阈值则丢弃。漏桶以固定速率释放请求，直到漏桶为空。
		- 漏桶算法重视总量控制，最高请求是多少。
		- **漏桶尽可能的缓冲请求，只有缓冲不了才丢弃**。适合突发场景的流量大问题，如整点秒杀，签到等。
	- 令牌桶算法
		- 以 r 的速率向令牌桶中增加令牌，直到桶满。请求从令牌中获取令牌，超过则限流。
		- 令牌桶算法重视速率控制，平均速率是多少。
		- **令牌桶尽可能的稳定请求，请求消费不了就丢弃**，适合控制访问速率，避免偶然抖动。
- 分布式 ID
	- 要求
		- 高性能
		- 高可用
		- 有序递增
		- 接入简单
		- 安全，不包含敏感信息
	- 实现
		- Nosql 生成
		- UUID
		- 雪花算法等

# 分布式事务

## 分布式事务出现场景

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601110159.png)

在多种业务场景下，单机事务无法满足业务需求，涉及到分布式事务的需求，如以下几种情况：
- 跨库事务：业务逻辑本身操作了多个库。

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601125024.png)

- 分库分表：分库分表后涉及多库/表数据的读写。
	
	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601125054.png)

- 微服务架构下服务间请求
	
	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601125116.png)

## 分布式事务缺陷之 CAP 定理

### CAP 概念

对于分布式事务，有以下三个特性：一致性，可用性与分区容错性。

1. 一致性 (Consistency)

	数据一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，不能存在中间状态。
	
	分布式环境中，一致性是指多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处理一致的状态。
	
	数据一致性分为强一致性、弱一致性、最终一致性：
	- 如果的确能像上面描述的那样时刻保证客户端看到的数据都是一致的，那么称之为强一致性。
	
	- 如果允许存在中间状态，只要求经过一段时间后，数据最终是一致的，则称之为最终一致性。
	
	- 此外，如果允许存在部分数据不一致，那么就称之为弱一致性。

2. 可用性 (Availability)

	系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在**有限的时间**内返回**正常的结果**。

3. 分区容错性 (Partition tolerance)

	即分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

### 分布式事务的权衡

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601131940.png)

**对于 C、A、P 三个方面，同时满足这是不可能的**。2000 年 7 月 Eric Brewer 教授仅仅提出来的是一个猜想，2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP 理论，并且而一个分布式系统最多只能满足 CAP 中的 2 项。之后，CAP 理论正式成为分布式计算领域的公认定理。

可以做一个假设，对于分布式事务，通常分区容错性是需要做到的，如果做不到，那么分布式就没有意义了。在此基础上，对于 AP 两个方面，如果需要满足一致性 (强一致性)，那么意味着任意时刻所有节点数据都应该相同。这就意味着对任一节点数据的读写必须同步到其他节点，其他节点在此期间无法操作该数据，否则就会造成数据不一致。由于这个限制，可用性就无法保证。如果在写入期间数据阻塞时间很长，那么必然会导致可用性的丧失。

1. 放弃 P

	放弃分区容错性的话，则放弃了分布式，放弃了系统的可扩展性。

2. 放弃 A

	放弃可用性的话，则在遇到网络分区或其他故障时，受影响的服务需要等待一定的时间，再此期间无法对外提供政策的服务，即不可用。

3. 放弃 C

	放弃一致性的话 (这里指强一致)，则系统无法保证数据保持实时的一致性，在数据达到最终一致性时，有个时间窗口，在时间窗口内，数据是不一致的。

在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。但是对于金融业务而言，一致性往往是更重要的。对于金融数据甚至可以牺牲可用性来保证一致性，即使不可用也要保证数据是一致的。

### CAP 与 ACID 的区别

- A 的区别:

	ACID 中的 A 指的是原子性 (Atomicity)，是指事务被视为一个不可分割的最小工作单元，事务中的所有操作要么全部提交成功，要么全部失败回滚; CAP 中的 A 指的是可用性 (Availability)，是指集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。

- C 的区别:

	ACID 一致性是有关数据库规则，数据库总是从一个一致性的状态转换到另外一个一致性的状态; CAP 的一致性是分布式多服务器之间复制数据令这些服务器拥有同样的数据，由于网速限制，这种复制在不同的服务器上所消耗的时间是不固定的，集群通过组织客户端查看不同节点上还未同步的数据维持逻辑视图，这是一种分布式领域的一致性概念。

ACID 里的一致性指的是事务执行前后，数据库完整性，而 CAP 的一致性，指的是分布式节点的数据的一致性。背景不同，无从可比。

## CAP 扩展之 BASE 理论

CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸，对于 C 我们采用的方式和策略就是**保证最终一致性**。

BASE 是 Basically Available (基本可用)、Soft state (软状态) 和 Eventually consistent (最终一致性) 三个短语的缩写。BASE 基于 CAP 定理演化而来，核心思想是即时无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

1. Basically Available (基本可用)

	基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用
	性，但不等于系统不可用。允许响应时间的损失 (时间变长) 与功能的损失 (服务降级)。

2. Soft state (软状态)

	指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

3. Eventually consistent (最终一致性)

	强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

	Eventually 含义为最终的意思，关于词典的解释为 `in the end, especially after a long time or a lot of effort, problems, etc.`。即意味着**无论经过多长的时间，耗费多少的努力，都要达到这一目标，数据的最终一致性**。

	对于最终一致性，又可分为以下几种：
	1. 因果一致性 (Causal consistency)

		即进程 A 在更新完数据后通知进程 B，那么之后进程 B 对该项数据的范围都是进程 A 更新后的最新值。
	
	2. 读己之所写 (Read your writes)

		进程 A 更新一项数据后，它自己总是能访问到自己更新过的最新值。
	
	3. 会话一致性 (Session consistency)

		将数据一致性框定在会话当中，在一个会话当中实现读己之所写的一致性。即执行更新后，客户端在同一个会话中始终能读到该项数据的最新值。
	
	4. 单调读一致性 (Monotonic read consistency)

		如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。
	
	5. 单调写一致性 (Monotoic write consistency)

		一个系统需要保证来自同一个进程的写操作被顺序执行。

BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的。BASE 理论的核心思想是: **即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性**。

BASE 理论是对 CAP 理论的延伸和补充，主要是对 AP 的补充。牺牲数据的强一致性，来保证数据的可用性，虽然存在中间装填，但数据最终一致。

ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。

## 刚性事务

刚性事务指的是分布式事务要像本地式事务⼀样，具备数据强⼀致性。从 CAP 来看就是要达到 CP 状态。

常见的刚性事务方案有：XA 协议（2PC、JTA、JTS）、3PC。由于刚性事务同步阻塞，处理效率低，不适合⼤型⽹站分布式场景。

### 刚性事务之 XA 模型

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601224523.png)

XA 规范是 X/Open 组织定义的分布式事务处理 (DTP，Distributed Transaction Processing) 标准。规范描述了全局的事务管理器与局部的资源管理器之间的接口。 

对于 XA 模型，包含三个角色：
1. AP：Applicaiton，应用程序

	业务层，哪些操作属于⼀个事务，就是 AP 定义的。

2. TM：Transaction Manager

	接收 AP 的事务请求，对全局事务进⾏管理，管理事务分⽀状态，协调 RM 的处理，通知 RM 哪些操作属于哪些全局事务以及事务分⽀等等。这个也是整个事务调度模型的核⼼部分。

3. RM：Resource Manager，资源管理器

	⼀般是数据库，也可以是其他的资源管理器，如消息队列 (如 JMS 数据源)，⽂件系统等。

XA 规范的目的是允许的多个资源 (如数据库，应用服务器，消息队列等) 在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA 规范使用两阶段提交 (2PC，Two-Phase Commit) 协议来保证所有资源同时提交或回滚任何特定的事务。目前知名的数据库，如 Oracle, DB2, mysql 等，都是实现了 XA 接口的，都可以作为 RM。

规范定义了 (全局) 事务管理器 (Transaction Manager) 和 (局部) 资源管理器 (Resource Manager) 之间的接口。XA 接口是双向的系统接口，在事务管理器 (Transaction Manager) 以及一个或多个资源管理器 (Resource Manager) 之间形成通信桥梁。

XA 之所以需要引入事务管理器是因为，在分布式系统中，从理论上讲 (参考 Fischer 等的论文)，两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源 (如数据库或 JMS 队列)

XA 是数据库的分布式事务，强一致性，在整个过程中，数据一张锁住状态，即从 prepare 到 commit、rollback 的整个过程中，TM 一直把持折数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在⻓事务⻛险。

XA 模型的处理流程如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601225135.png)


### XA 实现之 JTA

Java 平台上事务规范 JTA (Java Transaction API) 也定义了对 XA 事务的支持，实际上，JTA 是基于 XA 架构上建模的，在 JTA 中，事务管理器抽象为 `javax.transaction.TransactionManager` 接口，并通过底层事务服务 (即 JTS) 实现。像很多其他的 java 规范一样，JTA 仅仅定义了接口，具体的实现则是由供应商 (如 J2EE 厂商) 负责提供。目前 JTA 的实现主要由以下几种:

- J2EE 容器所提供的 JTA 实现 (JBoss)。

- 独立的 JTA 实现: 如 JOTM，Atomikos。

这些实现可以应用在那些不使用 J2EE 应用服务器的环境里用以提供分布事事务保证。如 Tomcat, Jetty 以及普通的 java 应用。

JTA 定义了一套接口，其中约定了几种主要的⻆色: TransactionManager、UserTransaction、Transaction、XAResource，并定义了这些⻆色之间需要遵守的规范，如 Transaction 的委托给 TransactionManager 等。JTS 也是一组规范，对于 JTA 中需要⻆色之间的交互，JTS 就是约定了交互细节的规范。总体上来说 JTA 更多的是从框架的⻆度来约定程序⻆色的接口，而 JTS 则是从具体实现的⻆度来约定程序⻆色之间的接口，两者各司其职。

### XA 实现之 2PC 协议

#### 2PC 过程

广泛应用在数据库领域，为了使得基于分布式架构的所有节点可以在进行事务处理时能够保持原子性和一致性。绝大部分关系型数据库，都是基于 2PC 完成分布式的事务处理。

2PC 分为两个阶段处理：

1. 提交事务请求

	1. 事务询问。协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待各参与者进行响应。
	
	3. 执行事务。各参与者节点，执行事务操作，并将 Undo 和 Redo 操作计入本机事务日志。
	
	5. 各参与者向协调者反馈事务问询的响应。成功执行返回 Yes，否则返回 No。
	

2. 执行事务提交

	协调者在阶段二决定是否最终执行事务提交操作。这一阶段包含两种情形:

	1. 执行事务提交：所有参与者 reply Yes，那么执行事务提交。

		1. 发送提交请求，协调者向所有参与者发送 Commit 请求。
		
		2. 事务提交，参与者收到 Commit 请求后，会正式执行事务提交操作，并在完成提交操作之后，释放在整个事务执行期间占用的资源。
		
		3. 反馈事务提交结果，参与者在完成事务提交后，写协调者发送 Ack 消息确认。
		
		4. 完成事务，协调者在收到所有参与者的 Ack 后，完成事务。

		![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601230521.png)

	1. 中断事务：当存在某一参与者向协调者发送 No 响应，或者等待超时。协调者只要无法收到所有参与者的 Yes 响应，就会中断事务。

		1. 发送回滚请求：协调者向所有参与者发送 Rollback 请求。
		
		2. 回滚：参与者收到请求后，利用本机 Undo 信息，执行 Rollback 操作。并在回滚结束后释放该事务所占用的系统资源。
		
		3. 反馈回滚结果：参与者在完成回滚操作后，向协调者发送 Ack 消息。
		
		4. 中断事务：协调者收到所有参与者的回滚 Ack 消息后，完成事务中断。

		![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601230541.png)

对于 2PC 的过程，总结如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601231243.png)


#### 2PC 优缺点

优点：
- 2PC 解决的是分布式数据强一致的问题。

- 2PC 方案比较适合单体应用跨多个库的分布式事务。而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。

缺点：
- 性能问题
	2PC 的提交在执行过程中，所有参与事务操作的逻辑都处于阻塞状态，也就是说，各个参与者都在等待其他参与者响应，无法进行其他操作。

- 单点故障问题
	事务协调者是整个 XA 模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。如果 RM 资源没有超时机制的话，此时就会陷入永久的阻塞。

- 数据不一致问题
	在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。

### 2PC 改进之 3PC 协议

针对 2PC 的缺点，研究者提出了 3PC，即 Three-Phase Commit。作为 2PC 的改进版，3PC 将原有的两阶段过程，重新划分为 CanCommit、 PreCommit 和 do Commit 三个阶段。

#### 3PC 过程

1. CanCommit

	1. 事务询问，协调者向所有参与者发送包含事务内容的 canCommit 的请求，询问是否可以执行事务提交，并等待应答。
	
	2. 各参与者反馈事务询问，正常情况下，如果参与者认为可以顺利执行事务，则返回 Yes，否则返回 No。

2. PreCommit

	在本阶段，协调者会根据上一阶段的反馈情况来决定是否可以执行事务的 PreCommit 操作。有以下两种可能:
	
	1. 执行事务预提交
	
		1. 发送预提交请求。协调者向所有节点发出 PreCommit 请求，并进入 prepared 阶段。
		
		2. 事务预提交。参与者收到 PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 日志写入本机事务日志;
		
		3. 各参与者成功执行事务操作，同时将反馈以 Ack 响应形式发送给协调者，同事等待最终的 Commit 或 Abort 指令。
		
	2. 中断事务：假如任意一个参与者向协调者发送 No 响应，或者等待超时，协调者在没有得到所有参与者响应时，即可以中断事务。
	
		1.  发送中断请求。协调者向所有参与者发送 Abort 请求。
		
		2.  中断事务。无论是收到协调者的 Abort 请求，还是等待协调者请求过程中出现超时，参与者都会中断事务。

1. DoCommit

	在这个阶段，会真正的进行事务提交，同样存在两种可能：
	
	1. 执行提交
	
		1. 发送提交请求。假如协调者收到了所有参与者的 Ack 响应，那么将从预提交转换到提交状态，并向所有参与者，发送 doCommit 请求。
		
		2. 事务提交。参与者收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交操作后释放占用资源。
		
		3. 反馈事务提交结果。参与者将在完成事务提交后，向协调者发送 Ack 消息;
		
		4. 完成事务。协调者接收到所有参与者的 Ack 消息后，完成事务。
	    
	2. 中断事务：在该阶段，假设正常状态的协调者接收到任一个参与者发送的 No 响应，或在超时时间内，仍旧没收到反馈消息，就会中断事务。
	
		1. 发送中断请求。协调者向所有的参与者发送 abort 请求。
		
		2. 事务回滚。参与者收到 abort 请求后，会利用阶段二中的 Undo 消息执行事务回滚，并在完成回滚后释放占用资源。
		
		3. 反馈事务回滚结果。参与者在完成回滚后向协调者发送 Ack 消息。
		
		4. 中端事务。协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断。

3PC 过程总结如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601233401.png)

#### 3PC 优缺点

优点：
- 相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。

- 通过 CanCommit、PreCommit、DoCommit 三个阶段的设计，相较于 2PC 而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。

缺点：
- 由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。

- 3PC 依然没有完全解决数据不一致的问题。假如在 DoCommit 过程，参与者 A 无法接收协调者的通信，那么参与者 A 会自动提交，但是提交失败了，其他参与者成功了，此时数据就会不一致。

### XA 模型缺陷分析

1. 数据锁定: 数据在事务未结束前，为了保障一致性，根据数据隔离级别进行锁定。

2. 协议阻塞: 本地事务在全局事务没 commit 或 callback 前都是阻塞等待的。

3. 性能损耗高: 主要体现在事务协调增加的 RT 成本，并发事务数据使用锁进行竞争阻塞。

4. 协调者依赖独立的 J2EE 中间件 (早期重量级 Weblogic、Jboss、后期轻量级 Atomikos、Narayana 和 Bitronix)。

5. 运维复杂，且并不是所有资源都支持 XA 协议。

## 柔性事务

柔性事务指的是，不要求强⼀致性，⽽是要求最终⼀致性，允许有中间状态。也就是 Base 理论，换句话说，就是 AP 状态。

柔性事务有两个特性： 基本可用和柔性状态。基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。柔性状态是指允许系统存在中间状态，这个中间状态不会影响系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是最终一致性。

与刚性事务相比，柔性事务的特点为：有业务改造，最终⼀致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。

### 通知型柔性事务

通知型事务的主流实现是通过 MQ (消息队列) 来通知其他事务参与者自己事务的执行状态，引入 MQ 组件，有效的将事务参与者进行解耦，各参与者都可以异步执行，所以通知型事务又被称为异步事务。因此通知型事务主要适用于那些需要异步更新数据，并且对数据的实时性要求较低的场景。

#### 异步确保型事务

异步确保型事务指指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免
分布式事务中同步阻塞带来的数据操作性能的下降。主要适用于内部系统的数据最终一致性保障，因为内部相对比较可控，如订单和购物⻋、收货与清算、支付与结算等等场景。

##### MQ 事务消息方案

基于 MQ 的事务消息方案主要依靠 MQ 的半消息机制来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴的 2PC 的思路，是二阶段提交的广义拓展。

半消息：在原有队列消息执行后的逻辑，如果后面的本地逻辑出错，则不发送该消息，如果通过则告知 MQ 发送;

事务消息的流程如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220601235216.png)

1. 事务发起方首先发送半消息到 MQ。

2. MQ 通知发送方消息发送成功。

3. 在发送半消息成功后执行本地事务。

4. 根据本地事务执行结果返回 commit 或者是 rollback。

5. 如果消息是 rollback, MQ 将丢弃该消息不投递; 如果是 commit，MQ 将会消息发送给消息订阅方。

6. 订阅方根据消息执行本地事务。

7. 订阅方执行本地事务成功后再从 MQ 中将该消息标记为已消费。

8. 如果执行本地事务过程中，执行端挂掉，或者超时，MQ 服务器端将不停的询问 producer 来获取事务状态。

9. Consumer 端的消费成功机制有 MQ 保证。

事务消息的优缺点：

优点：事务消息形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。

缺点：事务消息仍无法百分百满足数据一致性。设想这么一个场景，当本地事务提交后，事务消息提交失败的话则会出现不一致的现象。对于此种情况 Rocket 提供了事务反查机制，Kafka 则是直接抛出异常。即使消息成功发送，消息的消费情况还需要消费端去做控制，同时还要求消费端处理幂等问题。

##### 本地消息表方案

有时候我们目前的 MQ 组件并不支持事务消息，或者我们想尽量少的侵入业务方。这时我们需要另外一种方案“基于 DB 本地消息表“。

本地消息表最初由 eBay 提出来解决分布式事务的问题。是目前业界使用的比较多的方案之一，它的核心思想就是将分布式事务拆分成本地事务进行处理。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220602000029.png)

发送消息方:

1. 需要有一个消息表，记录着消息状态相关信息。

2. 业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。

3. 在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ 消息队列。使用专⻔的投递工作线程进行事务消息投递到 MQ。

4. 根据投递 ACK 去删除事务消息表记录消息会发到消息消费方，如果发送失败，即进行重试。

消息消费方:

1. 处理消息队列中的消息，完成自己的业务逻辑。

2. 如果本地事务处理成功，则表明已经处理成功了。

3. 如果本地事务处理失败，那么就会重试执行。

4. 如果是业务层面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

本地消息表优缺点:

优点:

- 本地消息表建设成本比较低，实现了可靠消息的传递确保了分布式事务的最终一致性。

- 无需提供回查方法，进一步减少的业务的侵入。

- 在某些场景下，还可以进一步利用注解等形式进行解耦，有可能实现无业务代码侵入式的实现。

缺点:

- 本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。 

- 本地消息表是基于数据库来做的，而数据库是要读写磁盘 IO 的，因此在高并发下是有性能瓶颈的。

##### MQ 事务消息与本地消息表对比

二者的共性:

- 事务消息都依赖 MQ 进行事务通知，所以都是异步的。

- 事务消息在投递方都是存在重复投递的可能，需要有配套的机制去降低重复投递率，实现更友好的消息投递去重。

- 事务消息的消费方，因为投递重复的无法避免，因此需要进行消费去重设计或者服务幂等设计。

二者的区别:

- MQ 事务消息

	- 需要 MQ 支持半消息机制或者类似特性，在重复投递上具有比较好的去重处理。
	
	- 具有比较大的业务侵入性，需要业务方进行改造，提供对应的本地操作成功的回查功能。

- DB 本地消息表

	- 使用了数据库来存储事务消息，降低了对 MQ 的要求，但是增加了存储成本。
	
	- 事务消息使用了异步投递，增大了消息重复投递的可能性。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220602000948.png)

#### 最大努力通知

最大努力通知方案的目标，就是发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方。最大努力通知事务主要用于外部系统，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接、商户通知等等跨平台、跨企业的系统间业务交互场景。

最大努力通知的一致性本质是通过引入定期校验机制实现最终一致性，对业务的侵入性较低，适合于对最终一致性敏感度比较低、业务链路较短的场景。

##### MQ 事务消息方案

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220602001728.png)

最大努力通知事务在投递之前，跟异步确保型流程都差不多，关键在于投递后的处理。因为异步确保型在于内部的事务处理，所以 MQ 和系统是直连并且无需严格的权限、安全等方面的思路设计。最大努力通知事务在于第三方系统的对接，所以最大努力通知事务有几个特性：
- 业务主动方在完成业务处理后，向业务被动方 (第三方系统) 发送通知消息，允许存在消息丢失。 

- 业务主动方提供递增多挡位时间间隔 (5min、10min、30min、1h、 24h)，用于失败重试调用业务被动方的接口。

- 在通知 N 次之后就不再通知，报警+记日志+人工介入。 

- 业务被动方提供幂等的服务接口，防止通知重复消费。 

- 业务主动方需要有定期校验机制，对业务数据进行兜底，防止业务被动方无法履行责任时进行业务回滚，确保数据最终一致性。

- 主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息。

- 业务活动的被动方如果正常接收了数据，就正常返回响应，并结束事务。

- 如果被动方没有正常接收，根据定时策略，向业务活动主动方查询，恢复丢失的业务消息。

##### 本地消息表方案

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220602001944.png)

消息的实现与异步确认式的本地消息表方案相同，对于消息消费的特性与最大努力特性的 MQ 事务消息相同，业务方需要提供重试机制，第三方系统需要提供幂等接口等。

#### 异步确保型事务与最大努力通知对比

- 从参与者来说：最大努力通知事务适用于跨平台、跨企业的系统间业务交互。异步确保型事务更适用于同网络体系的内部服务交付。  

- 从消息层面说：最大努力通知事务需要主动推送并提供多档次时间的重试机制来保证数据的通知。而异步确保型事务只需要消息消费者主动去消费。  

- 从数据层面说：最大努力通知事务还需额外的定期校验机制对数据进行兜底，保证数据的最终一致性;。而异步确保型事务只需保证消息的可靠投递即可，自身无需对数据进行兜底处理。

#### 通知型事务的缺陷

- **通知型事务，是无法解决本地事务执行和消息发送的一致性问题的**。因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现。

- 消息重复发送会导致业务处理接口出现重复调用的问题。消息消费过程中消息重复发送的主要原因就是消费者成功接收处理完消息后，消息中间件没有及时更新投递状态导致的。如果允许消息重复发送，那么消费方应该实现业务接口的幂等性设计。

### 补偿性事务



