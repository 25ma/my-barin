# 一、数据密集系统概念
数据密集性系统遵守若干基本原则，其中以下三个原则先得尤为重要。
- 可靠性
	容忍硬件，软件或者认为的错误。
- 可扩展性
	评测负载与性能，延迟百分位数，吞吐量等。随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。
- 可维护性
	可运维，简单与可演化。

这些原则是为了应对数据量，数据的复杂度以及数据的快速多边性而做出的努力。
 
设计数据系统或数据服务时，一定会碰到很多棘手的问题。例如，当系统内出现了局部失效时，如何确保数据的正确性与完整性? 当发生系统降级 (degrade) 时，该如何为客户提供一致的良好表现? 负载增加时，系统如何扩展? 友好的服务 API 该如何设计？

# 二、数据模型

## (一)、数据模型分类
- 关系数据模型
- 文档数据模型
- 图数据模型
  在属性图模型中，每个顶点包括：
  - 唯一的标识符。
  - 出边的集合。
  - 人边的集合。
  - 属性的集合（键-值对）

  每个边包括：
  - 唯一的标识符。
  - 边结束的顶点
  - 头部顶点
  - 描述两个顶点间关系类型的标签。
  - 属性的集合（键-值对）
  - 边开始的顶点（尾部顶点
  
  图查询语言
  - Cypher 查询语言
  	 Cypher 是一种用千属性图的声明式查询语言，最早为 Neo4j 图形数据库而创建。
  - 利用 SQL 建立关系表查询
  - 三元存储与 SPARQL
   在三元存储中，所有信息都以非常简单的三部分形式存储 (主体，谓语，客体)。例如，在三元组 (吉姆，喜欢，香蕉) 中，吉姆是主体，喜欢是谓语 (动词)，香蕉是客体。
   
   - Datalog
    Datalog 的数据模型类似千三元存储模式，但更为通用一些。它采用 “ 谓语 (主体，客体)” 的表达方式而不是三元组 (主体，谓语，客体)。
	
</br>
文档数据库和图数据库有一个共同点，那就是它们通常不会对存储的数据强加某个模式，这可以使应用程序更容易适应不断变化的需求。但是，应用程序很可能仍然假定数据具有一定的结构，只不过是模式是显式 (写时强制) 还是隐式 (读时处理) 的问题。

## (二)、数据查询语言
- 命令行语言
	命令行语言类似于程序代码的方式，通过命令行查询数据。
	```json
	function getSharks() { var sharks = [];
	for (var i = o; i < animals.length; i++) { 
		if (animals[i].family === "Sharks") {
			sharks.push(animals[i]);
		}}
		return sharks;
	}
	```

- 声明式语言
	声明式语言类似于 SQL。

# 三、数据存储与检索

## (一)、哈希表索引
 
 假设数据存储全部采用追加式文件组成，那么最简单的索引策略就是: 保存内存中的 hash map, 把每个键一一映射到数据文件中特定的字节偏移量，这样就可以找到每个值的位置。这就是 Bitcask (Riak 中的默认存储引擎) 所采用的核心做法。 Bitcask 可以提供高性能的读和写，只要所有的 key 可以放入内存 (因为 hash map 需要保存在内存中)。而 value 数据量则可以超过内存大小，只需一次磁盘寻址，就可以将 value 从磁盘加载到内存。如果那部分数据文件已经在文件系统的缓存中，则读取根本不需要任何的磁盘 I/0。
 
  Bitcask 这样的存储引擎非常适合每个键的值频繁更新的场景。
  
### 1. 追加式的设计优点：
 
 -  追加和分段合并主要是顺序写，它通常比随机写入快得多，特别是在旋转式磁性硬盘上。在 SSD 上也是适合的。
  -  段文件是追加的或不可变的，则并发和崩溃恢复要简单得多。
  -  合并旧段可以避免随着时间的推移数据文件出现碎片化的问题。
  
### 2. 哈希表索引局限性：
  
  - 哈希表必须存放在内存中，如果存放在磁盘中，需要大量的随机 IO 访问。
  - 区间查询效率不高，例如，不能简单地支持扫描 kittyooooo 和 kitty99999 区间内的所有键，只能采用逐个查找的方式查询每一个键。
  


## (二)、SSTables (SortStringTables)
  
### 1. SSTable 优势
   
   SSTables 要求 key-value 对的顺序按键排序，这样相比哈希索引表有以下优点：
   
   1. 合并段更加高效，可以采取类似归并排序的算法进行段合并。
   2. 查找特定 key 时，无需在内存中保存所有键的索引。 
   假设正在查找键 handiwork, 且不知道该键在段文件中的确切偏移。但是，如果知道键 handbag 和键 handsome 的偏移显，考虑到根据键排序，则键 handiwork 一定位千它们两者之间。
   这样代表着 `SSTables 索引可以是稀疏的`。
   3. 由于读请求往往需要扫描请求范围内的多个 key-value 对，可以考虑将这些记录存到一个块中并在存磁盘前压缩它们。稀疏内存索引每个条目指向每个压缩块的开头。这样除了节省磁盘空间，还减少了 IO 带宽。
   
### 2. SSTables 写入与维护
   
   将稀疏索引表保存在内存中（当然，磁盘中亦可，如 B-Tree），可以使用红黑树或 AVL 树。使用这些结构可以按任意顺序插入然后读取它们。
   1. 写入时，将其写入到内存的平衡树结构中，这个结构有时称为内存表。
   2. 内存表大于某个阈值（通常几兆字节），将其写入磁盘。写入的数据称为数据库最新的部分，当 SSTbale 写入磁盘时，新的索引写入可以添加到一个新的内存表实例。
   3.  为了处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标。
   4.  后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值。
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20211222230226.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20211222230244.png)
上述方案可以很好地工作。但它还存在一个问题: 如果数据库崩溃，最近的写入 (在内存表中但尚未写入磁盘) 将会丢失。
为了避免该问题，可以在 `磁盘上保留单独的日志，每个写入都会立即追加到该日志`，就像上一节哈希表索引存储的那样。这个日志文件不需要按键排序，这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当将内存表写入 SSTable 时，相应的日志可以被丢弃。

以上描述的算法本质上正是 LevelDB 压]和 RocksDB 所使用的，主要用千嵌入到其他应用程序的 key-value 存储引擎库。此外，在 Riak 中 LevelDB 可以用作 Bitcask 的替代品。类似的存储引擎还被用千 Cassandra 和 HBase, 这两个引擎都受到 Google 的 `Bigtable 论文` 的启发 (它引入了 SSTable 和内存表这两个术语)。

Lucene 是 Elasticsearch 和 Solr 等全文搜索系统所使用的索引引擎，它采用了类似的方法来保存其词典。

因为基于日志合并，所以这个被简称为 `Log-Structured Merge-Tree, 或 LSM-Tree`。

### 3.SSTables 优化
 
  1. 优化不存在的 key 查询
    查找数据库中某个不存在的键时， LSM-Tree 算法可能很慢: 在确定键不存在之前，必须先检查内存表，然后将段一直回溯访问到最旧的段文件 (可能必须从磁盘多次读取)。为了优化这种访问，存储引擎通常使用额外的布隆过滤器。
  2. 优化内存表的压缩与合并
  	1. 大小分级压缩
	   在大小分级的压缩中，较新的和较小的 SSTables 被连续合并到较旧和较大的 SSTables。
    2. 分层压缩
	   在分层压缩中，键的范围分裂成多个更小的 SSTables, 旧数据被移动到单独的 "层级”。
	   

## (三)、B-Trees

### 1. B-Tree 概念

 B-Tree 像 SSTable 一样， B-tree 保留按键排序的 key-value 对，这样可以实现高效的 key-value 查找和区间查询。 
 上面提到的 SSTables 日志结构索引将数据库分解为可变大小的段，通常大小为几兆字节或更大，并且始终按顺序写入段。相比之下， B-tree 将数据库分解成固定大小的块或页，传统上大小为 4 KB (有时更大)，页是内部读/写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。 
 每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存。可以使用这些页面引用来构造一个树状页面，如图 3-6 所示。
 某一页被指定为 B-tree 的根; 每当查找索引中的一个键时，总是从这里开始。该页面包含若干个键和对子页的引用。每个孩子都负责一个连续范围内的键，相邻引用之间的键可以指示这些范围之间的边界。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20211222232248.png)
