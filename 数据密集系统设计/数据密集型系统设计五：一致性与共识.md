#数据库 #分布式 

# 一致性保证

本章我们将讨论构建容错式分布式系统的相关算法和协议。这里假设[[数据密集系统设计/数据密集型系统设计四：分布式的挑战|分布式系统中所有的故障]]都可能发生，这包括网络数据包可能会丢失、顺序紊乱、重复发送或延迟，时钟也有一定偏差，节点可能发生暂停（例如由于垃圾回收）甚至随时崩溃。

我们尝试建立可以让分布式应用忽略内部各种问题的抽象机制。例如，**分布式系统最重要的抽象之一就是共识：所有的节点就某一项提议达成一致**。通过本章的介绍，最后你会发现面对各种网络故障和进程失效，可靠地达成共识是一件多么了不起的事情。一旦解决了共识问题，就可以服务于应用层很多的目标需求。

大多数多副本的数据库都至少提供了最终的一致性，这意味着如果停止更新数据库，并等待一段时间（长度未知）之后，最终所有读请求会返回相同的内容。换言之，**最终一致性意味着收敛，即预期所有的副本最终会收敛到相同的值**。

但是，这是一个非常弱的保证，它无法告诉我们系统何时会收敛。而**在收敛之前，读请求可能会返回任何值甚至读失败**。例如，如果完成一笔更新操作之后立即读取，由于读取可能会路由到不同的副本，系统不保证一定读到刚刚写入的值。对于应用开发入员而言，最终一致性会带来很大的处理挑战，这与普通的单线程程序中变垃读写行为大相径庭。 

## 可线性化

在最终一致性数据库中，同时查询两个不同的副本可能会得到两个不同的答案。这会使应用层感到困惑。如果数据库能够对上提供只有单个副本的假象，情况会不会大为简化呢？这样让每个客户端都拥有相同的数据视图，而不必担心复制滞后。这就是可线性化 (也称为原子一致性, 强一致性等) 的思想。 

线性化的确切定义比较微妙，其基本的想法是**让一个系统看起来好像只有一个数据副本，且所有的操作都是原子的**。有了这个保证，应用程序就不需要关心系统内部的多个副本。

一个非线性化的例子如下，后发生的请求看到了更老的数据：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627002753.png)

### 如何达到线性化？

可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。 

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627003008.png)

在一个可线性化的系统中，在写操作的开始与结束之间必定存在某个时间点，x 的值发生了从 0 到 1 的跳变。如果某个客户端的读取返回了新值 1，即使写操作尚未提交，那么所有后续的读取也必须全部返回新值。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627003126.png)

上图中的每个操作都有一条竖线，表示可能的执行时间点。这些标记以前后关系依次连接起来，最终的结果必须是一个有效的寄存器读写顺序，即每个读操作须返回最近写操作所设置的值。

可线性化要求，如果连接这些标记的竖线，它们必须总是按时间箭头（从左到右）向前移动，而不能向后移动。这个要求确保了之前所讨论的就近性保证： **一且新值被写入或读取，所有后续的读都看到的是最新的值，直到被再次覆盖。**

以上就是线性化背后的直觉含义。通过记录所有请求和响应的时序，然后检查它们是否可以顺序排列，可以用来测试系统是否可线性化（这里存在额外的计算开销）。

### 可线性化与可串行化

可线性化 (Linearizability) 非常容易与[[数据密集系统设计/数据密集型系统设计三：事务#1 3 串行化|可串行化 (Serializability) ]] 发生混淆。两个词似乎都在表达类似可以按顺序排列的意思。但是它们完全不同，需要仔细区分。

- 可串行化

	可串行化是事务的隔离属性，其中每个事务可以读写多个对象（行，文档，记录等）。它用来确保事务执行的结果与串行执行（即每次执行一个事务）的结果完全相同，即使串行执行的顺序可能与事务实际执行顺序不同。

- 可线性化

	**可线性化是读写寄存器（单个对象）的最新值保证**。它并不要求将操作组合到事务中，因此无法避免[[数据密集系统设计/数据密集型系统设计三：事务#1 2 4 写倾斜与幻读|写倾针]]等问题。除非采取其他额外措施（如实现[[数据密集系统设计/数据密集型系统设计三：事务#1 2 4 4 实体化冲突|实体化冲突]])。

数据库可以同时支持可串行化与线性化，这种组合又被称为严格的可串行化或者强的单副本可串行化 (strong one-copy serializabili ty, strong-lSR)。基于[[数据密集系统设计/数据密集型系统设计三：事务#1 3 2 两阶段加锁|两阶段加锁]]或者[[数据密集系统设计/数据密集型系统设计三：事务#1 3 1 实际串行化执行|实际以串行执行]]都是典型的可线性化。

但是，[[数据密集系统设计/数据密集型系统设计三：事务#1 3 3 可串行化的快照隔离|可串行化的快照隔离]]则不是线性化的：按照设计，它可以从一致性快照中读取，以避免读、写之间的竞争。**一致性快照的要点在于它里面不包括快照点创建时刻之后的写入数据**，因此从快照读取肯定不满足线性化。

### 线性化的依赖条件

那什么情况下应该使用线性化呢? 上面足球比赛比分的例子只是个最简单的情况，结果存在几秒的延迟通常不会造成实质的伤害。然而，在有些场景下，线性化对于保证系统正确工作至关重要。

#### 加锁与主节点选举

主从复制的系统需要确保有且只有一个主节点，否则会产生脑裂。选举新的主节点常见的方法是使用锁: 即每个启动的节点都试图获得锁，其中只有一个可以成功即成为主节点。不管锁具体如何实现，它必须满足可线性化: **所有节点都必须同意哪个节点持有锁**，否则就会出现问题。

提供协调者服务的系统如 Apache ZooKeeper 等通常用来实现分布式锁和主节点选举。它们都使用了支持容错的共识算法确保可线性化。归根结底，**线性化存储服务是所有这些协调服务的基础**。

#### 约束与唯一性保证

唯一性约束在数据库中很常见。例如，用户名或电子邮件地址必须唯一标识一个用户，文件存储服务中两个文件不能具有相同的路径和文件名。如果要在写入数据时强制执行这些约束，则也需要线性化。

这种情况本质上与加锁非常类似: 用户注册等同千试图对用户名进行加锁操作。该操作也类似千原子比较和设置: 如果当前用户名尚未被使用，就设置用户名与客户 ID 进行关联。

当然在某些实际场合中，有时可以放宽这些限制。然而，硬性的唯一性约束，常见如关系型数据库中主键的约束，则需要线性化保证。其他如外键或属性约束，则并不要求一定线性化。

#### 跨通道的时间依赖

在上面的例子中，如果 Alice 没有高呼比分， Bob 可能就不会知道他的查询结果是过期的。或许他会在几秒之后再次刷新页面，然后看到最终的比分。**线性化违例之所以被注意到，是因为系统中存在其他的通信渠道**（例如， Alice 对 Bob 发出的声音来传递信息）。

计筛机系统也会出现类似的情况。例如，用户可以上传照片到某网站，有一个后台进程将照片调整为更低的分辨率 (即缩略图) 以方便更快下载。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627205827.png)

如果文件存储服务是可线性化的，那么系统应该可以正常工作。否则，这里就会引入竞争条件险: 消息队列可能比存储服务内部的复制执行更快。在这种情况下，当调整模块在读取图像 (步骤 5) 时，可能会看到图像的某个旧版本，或者根本读不到任何内容。

之所以出现这个问题是因为 Web 服务器和调整模块之间**存在两个不同的通信通道**: 文件存储器和消息队列。如果没有线性化的就近性保证，这两个通道之间存在竞争条件。

线性化并非避免这种竞争的唯一方法，但却是最容易理解的。如果可以控制某一个通信通道 (例如消息队列，但注意不适合 Alice 和 Bob 的例子，因为后者并非计算机系统)，可以尝试[[数据密集型系统设计二：复制与分区#1 4 复制滞后问题|读自己读写]]方法，但会引入额外的复杂性。

### 实现线性化系统
