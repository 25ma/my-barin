#数据库 #分布式 

# 一致性保证

本章我们将讨论构建容错式分布式系统的相关算法和协议。这里假设[[数据密集系统设计/数据密集型系统设计四：分布式的挑战|分布式系统中所有的故障]]都可能发生，这包括网络数据包可能会丢失、顺序紊乱、重复发送或延迟，时钟也有一定偏差，节点可能发生暂停（例如由于垃圾回收）甚至随时崩溃。

我们尝试建立可以让分布式应用忽略内部各种问题的抽象机制。例如，**分布式系统最重要的抽象之一就是共识：所有的节点就某一项提议达成一致**。通过本章的介绍，最后你会发现面对各种网络故障和进程失效，可靠地达成共识是一件多么了不起的事情。一旦解决了共识问题，就可以服务于应用层很多的目标需求。

大多数多副本的数据库都至少提供了最终的一致性，这意味着如果停止更新数据库，并等待一段时间（长度未知）之后，最终所有读请求会返回相同的内容。换言之，**最终一致性意味着收敛，即预期所有的副本最终会收敛到相同的值**。

但是，这是一个非常弱的保证，它无法告诉我们系统何时会收敛。而**在收敛之前，读请求可能会返回任何值甚至读失败**。例如，如果完成一笔更新操作之后立即读取，由于读取可能会路由到不同的副本，系统不保证一定读到刚刚写入的值。对于应用开发入员而言，最终一致性会带来很大的处理挑战，这与普通的单线程程序中变垃读写行为大相径庭。 

## 可线性化

在最终一致性数据库中，同时查询两个不同的副本可能会得到两个不同的答案。这会使应用层感到困惑。如果数据库能够对上提供只有单个副本的假象，情况会不会大为简化呢？这样让每个客户端都拥有相同的数据视图，而不必担心复制滞后。这就是可线性化 (也称为原子一致性, 强一致性等) 的思想。 

线性化的确切定义比较微妙，其基本的想法是**让一个系统看起来好像只有一个数据副本，且所有的操作都是原子的**。有了这个保证，应用程序就不需要关心系统内部的多个副本。

一个非线性化的例子如下，后发生的请求看到了更老的数据：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627002753.png)

### 如何达到线性化？

可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。 

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627003008.png)

在一个可线性化的系统中，在写操作的开始与结束之间必定存在某个时间点，x 的值发生了从 0 到 1 的跳变。如果某个客户端的读取返回了新值 1，即使写操作尚未提交，那么所有后续的读取也必须全部返回新值。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220627003126.png)

上图中的每个操作都有一条竖线，表示可能的执行时间点。这些标记以前后关系依次连接起来，最终的结果必须是一个有效的寄存器读写顺序，即每个读操作须返回最近写操作所设置的值。

可线性化要求，如果连接这些标记的竖线，它们必须总是按时间箭头（从左到右）向前移动，而不能向后移动。这个要求确保了之前所讨论的就近性保证： **一且新值被写入或读取，所有后续的读都看到的是最新的值，直到被再次覆盖。**

以上就是线性化背后的直觉含义。通过记录所有请求和响应的时序，然后检查它们是否可以顺序排列，可以用来测试系统是否可线性化（这里存在额外的计算开销）。

### 可线性化与可串行化

可线性化 (Linearizability) 非常容易与[[数据密集系统设计/数据密集型系统设计三：事务#1 3 串行化|可串行化 (Serializability) ]] 发生混淆。两个词似乎都在表达类似可以按顺序排列的意思。但是它们完全不同，需要仔细区分。

- 可串行化

	可串行化是事务的隔离属性，其中每个事务可以读写多个对象（行，文档，记录等）。它用来确保事务执行的结果与串行执行（即每次执行一个事务）的结果完全相同，即使串行执行的顺序可能与事务实际执行顺序不同。

- 可线性化

	**可线性化是读写寄存器（单个对象）的最新值保证**。它并不要求将操作组合到事务中，因此无法避免[[数据密集系统设计/数据密集型系统设计三：事务#1 2 4 写倾斜与幻读|写倾针]]等问题。除非采取其他额外措施（如实现[[数据密集系统设计/数据密集型系统设计三：事务#1 2 4 4 实体化冲突|实体化冲突]])。

数据库可以同时支持可串行化与线性化，这种组合又被称为严格的可串行化或者强的单副本可串行化 (strong one-copy serializabili ty, strong-lSR)。基于[[数据密集系统设计/数据密集型系统设计三：事务#1 3 2 两阶段加锁|两阶段加锁]]或者[[数据密集系统设计/数据密集型系统设计三：事务#1 3 1 实际串行化执行|实际以串行执行]]都是典型的可线性化。

但是，[[数据密集系统设计/数据密集型系统设计三：事务#1 3 3 可串行化的快照隔离|可串行化的快照隔离]]则不是线性化的：按照设计，它可以从一致性快照中读取，以避免读、写之间的竞争。**一致性快照的要点在于它里面不包括快照点创建时刻之后的写入数据**，因此从快照读取肯定不满足线性化。

### 线性化的依赖条件

