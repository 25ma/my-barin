#消息队列

# 一、消息队列使用背景

## 使用消息队列可以解决什么事情

- 异步处理
	在原有处理流程中，明确出来哪些任务是前置必须要处理的，哪些任务是可以后续异步处理的。将前置处理的任务与后续异步处理的任务分离开来，一方面减少整个流程处理的时间，另一方面也可以将 **资源倾斜** 到前置任务的处理中，更有效的利用资源。
- 流量控制
	对于高并发请求的情况，为了避免请求同时到达服务器，可以采取 MQ 进行流量控制。对于访问请求将其加入 MQ 中，服务器不断消费 MQ 进行服务响应。
	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20211121180200.png)
	这种设计的优点是：能根据下游的处理能力自动调节流量，达到“削峰填谷”的作用。但这样做同样是有代价的：
	-  增加了系统调用链环节，导致总体的响应时延变长。
	- 上下游系统都要将同步调用改为异步消息，增加了系统的复杂度。

	那还有没有更简单一点儿的流量控制方法呢？如果我们能预估出服务的处理能力，就可以用消息队列实现一个令牌桶，更简单地进行流量控制。
	令牌桶控制流量的原理是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。
	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20211121180110.png)
	
	实现的方式也很简单，不需要破坏原有的调用链，只要网关在处理 APP 请求时增加一个获取令牌的逻辑。
	令牌桶可以简单地用一个有固定容量的消息队列加一个“令牌发生器”来实现：令牌发生器按照预估的处理能力，匀速生产令牌并放入令牌队列（如果队列满了则丢弃令牌），网关在收到请求时去令牌队列消费一个令牌，获取到令牌则继续调用后端秒杀服务，如果获取不到令牌则直接返回处理失败。
	当然，令牌桶并不一定要基于 MQ 实现，采用其他方式（如 Redis）同样能实现此功能。
	
- 服务解偶
	当一个服务处理完数据后，若下游系统需要进行一些相关的处理，则可以采取 MQ 解偶的方式。无论增加、减少下游系统或是下游系统需求如何变化，服务都无需做任何更改，实现了本服务与下游服务的解耦。
-   作为发布 / 订阅系统实现一个微服务级系统间的观察者模式。
-   连接流计算任务和数据。
-   用于将消息广播给大量接收者。

## 消息队列带来哪些问题

同时我们也要认识到，消息队列也有它自身的一些问题和局限性，包括：

-   引入消息队列带来的延迟问题；
-   增加了系统的复杂度；
-   可能产生数据不一致的问题。

## 消息队列产品的选择

### 选择标准

- 尽量开源。开源意味着如果发现什么 Bug 可以自己着手解决，而不必依赖于消息队列产品提供方的更新。
- 近期流行且具有一定活跃度。一方面流行与活跃度高意味着碰见问题概率低及解决问题效率高。另一方面是与 **周边生态** 会有一个好的集成与兼容。
- 消息的可靠传递。
- Cluster，支持集群。
- 具备优秀的性能。

总结有以下功能，选择是尽量考虑以下方面：不丢消息、支持消息持久化、保证不重复消费、支持顺序消费、支持集群，用的人多，支持的人多，兼容的产品多。

### 一些推荐

- RabbitMQ
	RabbitMQ 活跃存在，轻量便捷。RabbitMQ 一个优秀的功能是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个 Exchange 模块。这个 Exchange 模块的作用和交换机也非常相似，根据配置的路由规则将生产者发出的消息分发到不同的队列中。路由的规则也非常灵活，甚至你可以自己来实现路由规则。基于这个 Exchange，可以产生很多的玩儿法，如果你正好需要这个功能，RabbitMQ 是个不错的选择。
	但是 RabbitMQ 也存在一些问题：
	- RabbitMQ 对消息堆积的支持并不好。
	在它的设计理念里面，消息队列是一个管道，大量的消息积压是一种不正常的情况，应当尽量去避免。当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。
	- RabbitMQ 的性能并不是非常优异，依据硬件配置的不同，它大概每秒钟可以处理几万到十几万条消息。其实，这个性能也足够支撑绝大多数的应用场景了，不过，如果你的应用对消息队列的性能要求非常高，那不要选择 RabbitMQ。
	- RabbitMQ 使用的编程语言 Erlang，这个语言的学习曲线非常陡峭，不利于开发者对其进行二次开发。
	
- RocketMQ
	RocketMQ 是阿里巴巴在 2012 年开源的消息队列产品，后来捐赠给 Apache 软件基金会，2017 正式毕业，成为 Apache 的顶级项目。阿里内部也是使用 RocketMQ 作为支撑其业务的消息队列，经历过多次“双十一”考验，它的性能、稳定性和可靠性都是值得信赖的。
	RocketMQ 的性能比 RabbitMQ 要高一个数量级，每秒钟大概能处理几十万条消息，RocketMQ 的设计选择更多的是**尽量及时处理请求**。
	RocketMQ 的一个劣势是，作为国产的消息队列，相比国外的比较流行的同类产品，在国际上还没有那么流行，与周边生态系统的集成和兼容程度要略逊一筹。
	
- Kafka
	Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。
	Kafka 使用 Scala 和 Java 语言开发，设计上大量使用了批量和异步的思想，这种设计使得 Kafka 能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息。
	Kafka 这种异步批量的设计带来的问题是，它的同步收发消息的响应时延比较高，因为当客户端发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送，在它的 Broker 中，很多地方都会使用这种“先攒一波再一起处理”的设计，它更关注的是**整体的吞吐量**。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，**Kafka 不太适合在线业务场景。**
	
- ActiveMQ
	ActiveMQ 是最老牌的开源消息队列，是十年前唯一可供选择的开源消息队列，目前已进入老年期，社区不活跃。无论是功能还是性能方面，ActiveMQ 都与现代的消息队列存在明显的差距，它存在的意义仅限于兼容那些还在用的爷爷辈儿的系统。

- ZeroMQ
	严格来说 ZeroMQ 并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用 ZeroMQ。

- Pulsar
	Pulsar 是一个新兴的开源消息队列产品，最早是由 Yahoo 开发，目前处于成长期，流行度和成熟度相对没有那么高。与其他消息队列最大的不同是，Pulsar 采用**存储和计算分离**的设计。
